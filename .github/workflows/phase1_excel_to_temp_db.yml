# .github/workflows/phase1_excel_to_temp_db.yml
name: Phase 1 - Merge Excel to Temp SQLite

on:
  push:
    paths:
      - 'conversation/csv/scanning.xlsx'
      - 'conversation/csv/prices.xlsx'

jobs:
  merge_and_prepare_temp_db:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Check if both files exist
        run: |
          if [ ! -f "conversation/csv/scanning.xlsx" ] || [ ! -f "conversation/csv/prices.xlsx" ]; then
            echo "Both scanning.xlsx and prices.xlsx must exist in the repository!"
            exit 1
          fi

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install Required Python Packages
        run: pip install pandas openpyxl sqlite-utils

      - name: Merge XLSX Files and Create Temp SQLite + Log File
        run: |
          python3 <<EOF
          import pandas as pd
          import sqlite3
          import os
          from datetime import datetime
          import traceback

          try:
              scan_file = "conversation/csv/scanning.xlsx"
              price_file = "conversation/csv/prices.xlsx"

              os.makedirs("conversation/Temp", exist_ok=True)
              log_path = "conversation/Temp/conversion_log.txt"

              with open(log_path, "w") as logfile:
                  now = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
                  logfile.write(f"{now} Workflow Started.\n")
                  logfile.write(f"{now} Processing input files.\n")

              scan_df = pd.read_excel(scan_file)
              price_df = pd.read_excel(price_file)

              # Ensure only Barcode and OriginalPrice columns are used from prices.xlsx
              price_df["OriginalPrice"] = pd.to_numeric(price_df["OriginalPrice"], errors='coerce')
              price_df = price_df[["Barcode", "OriginalPrice"]]

              merged_df = pd.merge(scan_df, price_df, on="Barcode", how="left")

              # Process OriginalPrice column: remove decimals and handle empty values
              merged_df["OriginalPrice"] = merged_df["OriginalPrice"].apply(
                  lambda x: str(int(x)) if pd.notna(x) and x == int(x) else ('' if pd.isna(x) else str(x))
              )

              final_columns = ["Barcode", "Article", "Percentage", "OriginalPrice"]
              merged_df = merged_df[final_columns]

              db_name = "conversation/Temp/temp.db"
              conn = sqlite3.connect(db_name)
              merged_df.to_sql("sc", conn, if_exists="replace", index=False, dtype={'OriginalPrice': 'TEXT'})
              conn.commit()
              conn.execute("VACUUM;")
              conn.close()

              # --- Log File Improvement ---
              with open(log_path, "a") as logfile:
                  now = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
                  logfile.write(f"{now} Data merged and temporary DB created.\n")
              # --- End Log File Improvement ---

              # --- version.txt Automation Improvement ---
              # Generate a unique version name based on timestamp to ensure Phase 2 always triggers
              # This will be the name of the final DB and ZIP
              timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
              # You can combine scanning file name with timestamp if you prefer:
              # base_scan_name = os.path.splitext(os.path.basename(scan_file))[0]
              # version_name = f"{base_scan_name}_{timestamp}"
              version_name = f"DB_Version_{timestamp}" # Example: DB_Version_20250717_213736
              
              version_file_path = "conversation/Temp/version.txt"
              with open(version_file_path, "w") as vfile:
                  vfile.write(version_name + "\n")
              
              with open(log_path, "a") as logfile:
                  now = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
                  logfile.write(f"{now} Version file updated with: '{version_name}'.\n")
                  logfile.write(f"{now} Merging Complete.\n") # Final log line
              # --- End version.txt Automation Improvement ---

          except Exception as e:
              os.makedirs("conversation/Temp", exist_ok=True)
              log_path_error = "conversation/Temp/conversion_log.txt"
              with open(log_path_error, "a") as logfile:
                  now = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
                  logfile.write(f"{now} Error occurred in Phase 1: {str(e)}\n")
                  logfile.write(traceback.format_exc())
              raise

          EOF

      - name: Commit Temp DB and Log File
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add conversation/Temp/temp.db conversation/Temp/conversion_log.txt conversation/Temp/version.txt
          git commit -m "Phase 1: Prepared temp SQLite and updated version.txt"
          git push
